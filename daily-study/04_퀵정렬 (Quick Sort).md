## 알고리즘 공부 내용 정리

### 1. 정렬

#### 4. 퀵 정렬( Quick Sort)

앞서 살펴본 선택정렬, 버블정렬, 삽입정렬 알고리즘 모두 시간 복잡도 O(N^2)를 가지는 알고리즘이기때문에 데이터의 갯수가 10만개만 넘어가도 사용하기 어렵다. 그래서 대표적인 빠른 알고리즘이 바로 퀵 정렬 알고리즘이다.  퀵 정렬은 대표적인 **분할 정복** 알고리즘으로 평균 속도가 O(N * logN)이다. (선택,버블,삽입보다 빠른편, long은 거의 상수라고 볼 수 있음)

3 7 8 1 5 9 6 10 2 4 의 숫자들을 정렬하려고 한다.

이때 주로 맨 앞의 값을 피벗값으로 선택하게 된다. 3을 피벗값(기준)으로 선택하면 3부터 왼쪽에서 출발해 3보다 큰 값을 찾고 맨 끝에서부터(오른쪽에서 출발해) 3보다 작은 값을 찾고, 그 값들을 교환한다. 

그 과정을 하게 되면 3 **2** 8 1 5 9 6 10 **7** 4가되고, 

 3 2 **8 1** 5 9 6 10 7 4 상태에서  8과 1을 바꾸면 

3 2 **1 8** 5 9 6 10 7 4가 된다. 지금같은 상황을 엇갈린 상황이라고 한다. (작은 값의 인덱스가 큰 값의 인덱스보다 작은 경우) 엇갈린 상황이 되면 왼쪽(더 작은값)을 피벗값과 바꾼다. 그렇게 되면 1 2 **3** 8 5 9 6 10 7 4이 되며, 3은 정렬이 완료 되었다고 할 수 있다. 3의 왼쪽은 다 3보다 작은 값이 되고, 3의 오른쪽은 다 3보다 큰 값들의 집합이 된다. 즉 3을 기준으로 두 그룹으로 분할된 것이다. 그리고 이 후 분할된 그룹끼리 또 정렬을 진행하게 된다.

=> **'퀵 정렬'이란?**

**특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤 배열을 반으로 나누는** 방법이다.(여기서 반으로 나눈다는 원소를 두 집합으로 나눈다는 의미)



소스코드로 확인해보면

```c++
#include<stdio.h>

int number = 10;
int data[10] = {1,10,5,8,7,6,4,3,2,9};
	
	//start : 정렬을 수행하는 부분집합의 첫번째, end : 그 마지막 
void quickSort(int *data, int start, int end){
	if (start >= end) {   //원소가 1개인 경우 
			return;
	}
		
	int key = start ;  //키는 첫번째 원소
	int i = start + 1;  //왼쪽부터 하나씩 큰 값을 찾을 때 인덱스(왼쪽 출발지점)
						//키 값의 바로 오른쪽부터 이동하며 키값보다 큰 값을 찾게됨 
	int j = end;    //마지막에서부터 키값보다 작은값 찾기위해 왼쪽으로 이동(오른쪽 출발지점)
	int temp;
    
	//왼쪽부터 출발한 값이 오른쪽부터 출발한 값보다 작은경우까지만 반복) 
	while(i <= j) {   //엇갈릴 때까지 반복,엇갈리면 탈출 
		while(data[i] <= data[key]) {  //키값보다 큰 값을 만날때까지 i 오른쪽으로 이동 
				i++;
		} 
		//왼쪽으로만 값이 넘어가지 않도록해주면됨. 오른쪽은 굳이 설정할 필요 없음 
		while(data[j] >= data[key] &&  j > start) {  //키값보다 작은값을 만날때까지 반복 
			j--;
		}
		
		//위에 있는 두 while문의 등호만 바꿔주면 내림차순 정렬 가능(큰 값을 찾는 위치과 작은 값을 찾는 위치만 바꿔주면됨) 
		if (i > j){//현재 엇갈린 상태면 키 값과 교체 
		temp = data[j];
		data[j] = data[key];
		data[key] = temp;
		}
  		 
  		else {  //엇갈리지않았다면 큰값과 작은값 교체 
		temp = data[j];
		data[j] = data[i];
		data[i] = temp;
		}
	} 
		
	//키값을 기준으로 왼쪽과 오른쪽에서 다시 퀵 정렬 수행 
	quickSort(data, start,  j - 1);
	quickSort(data, j + 1,  end);
		 
	}
	

int main(void){
	quickSort(data, 0,  number - 1);
	for(int i = 0; i < number ; i++){
		printf("%d ", data[i]);
	}
}
```



'키 값보다 작은 값을 만날 때까지' 반복하는 부분에서 j가 start보다 클 때에 한해서만 반복문이 수행된다. 이는 항상 왼쪽에 있는 값과 피벗값을 교환하기 때문이다. 오른쪽에 있는 값은 피벗값과 교환되지 않기때문에 처리할 필요가 없다. 퀵 정렬 알고리즘은 기본적으로 N번씩 탐색하면서 반으로 쪼개 들어가기 때문에 log N을 곱한 복잡도를 가진다.



1 2 3 4 5 6 7 8 9 10을 정렬하는 경우로 생각해보면, N^2 = 10 * 10 = 100

분할해서 정렬하게 되면 1 2 3 4 5 / 6 7 8 9 10 각각 5*5=25가 되고, 25+25=50가 되기때문에 분할 정렬이 더 빠른 것이다



퀵 정렬의 평균 시간 복잡도는 => O(N * logN)

하지만 퀵정렬의 최악의 시간 복잡도는 O(N^2)이다.

피벗값 설정에 따라  O(N^2)까지 나오기도 하며 O(N * logN)를 보장할 수 없다.

1 2 3 4 5 6 7 8 9 10 을 정렬한다고 생각하면, 이와 같이 이미 정렬이 되어 있는 경우 퀵 정렬의 시간 복잡도는 O(N^2)에 가깝다.  (두 그룹으로 나누어 분할적으로 수행되는 분할정복의 이점 수행 불가)

가장 빠르게 정렬이 되려면 중간값의 피벗값으로 해야 빠르게 해결이 가능하다.



정렬 데이터 특성에 따라 적절한 알고리즘 선택이 중요하다.



*참조링크 : https://blog.naver.com/ndb796/221226813382*