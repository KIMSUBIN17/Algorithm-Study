## 알고리즘 공부 내용 정리

### 1. 정렬

#### 2. 버블 정렬( Bubble Sort)

다음 숫자를 오름차순으로 정렬하려면 어떻게 해야할까?

1 10 5 8 7 6 4 3 2 9 

앞서 살펴본 선택정렬과 같은 예제로 생각해보면 버블 정렬 또한 매우 직관적인 해결 방법이다. 바로 가까이에 있는 두 숫자끼리 비교하여 당장 더 작은 숫자를 앞으로 보내주는 것을 반복한다.

=> '버블 정렬'이란?

옆에 있는 값과 비교하여 더 작은 값을 반복적으로 앞으로 보내는 정렬 방법

```c
#include<stdio.h>

int main(void){
	int i,j,temp;
	int array[10] = {1,10,5,8,7,6,4,3,2,9};
	for(i = 0; i < 10; i++){
		for(j = 0; j< 9 - i; j++){
			if(array[j] > array[j + 1]){
				//swapping
				temp = array[j];
				array[j] = array [j+1];
				array[j+1] = temp;
			}
		}
	}
	for(i = 0; i< 10; i++){
		printf("%d ", array[i]);
	}
	return 0;
}
```



단순하게 반복적으로 이웃한 두 숫자를 비교하여 앞으로 보낸다. 이 과정에서 각 사이클마다 가장 큰 값이 맨 뒤로 보내지게 된다.

1번 반복시 집합의 크기가 1씩 줄어듦을 확인할 수 있다. 이처럼 반복을 진행 할수록 천천히 뒤에서부터 집합의 크기가 줄어간다. (소스코드에서 9 - i를 하는 이유)

비교연산의 횟수는 아래와 같다.

10 + 9 + 8 + 7 + ... + 1

=> 10 * (10 + 1) / 2 = 55번의 비교 연산 수행

=> N* (N + 1) / 2  

=> O(N * N)   

=> O(N^2)

버블 정렬의 시간 복잡도는  O(N^2)가 된다. 

선택 정렬과 시간 복잡도는 같지만 실제 구동시에는 버블 정렬이 더 느리다. 그 이유는 버블정렬은 바로 옆에 있는 값과 계속해서 반복,비교하여 자리를 매번 바꿔주는 연산을 진행하기 때문이다. (선택 정렬은 가장 작은 값 하나를 골라서 마지막에만 값을 바꿔줌)

