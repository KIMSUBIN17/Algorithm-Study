## 알고리즘 공부 내용 정리

### 1. 정렬

#### 6. 힙 정렬( Heap Sort)

힙 정렬은 병렬 정렬과 퀵 정렬만큼 빠른 정렬 알고리즘이다. 힙은 '힙 트리 구조(Heap Tree Structure)를 이용하는 정렬 방법'이다.

힙을 알려면 먼저 이진 트리(Binary Tree)에 대해서 알아야한다. 이진 트리란 컴퓨터 안에서 데이터를 표현할 때 데이터를 각 노드에 담은 뒤 노드를 두 개씩 이어 붙이는 구조로, *모든 노드의 자식 노드가 2개 이하인 노드*이다. 이 때 트리 구조에 맞게 부모 노드에서 자식 노드로 가지가 뻗힌다. 트리는 가지를 뻗어나가는 것처럼 데이터가 서로 연결되어 있는것을 말한다.

**완전 이진 트리**는 데이터가 루트(Root)노드부터 시작해서 자식 노드가 왼쪽 자식 노드, 오른쪽 자식 노드로 차례대로 들어가는 구조의 이진 트리이다. 완전 이진 트리는 이진 트리의 노드가 중간에 비어있지 않고 가득 찬 구조를 갖고 있다. 항상 왼쪽 자식 노드부터 데이터가 들어간다.

**힙(Heap)**은 최솟값이나 최댓값을 빠르게 찾아내기 위해 완전 이진 트리를 기반으로 하는 트리이다. 최대힙과 최소힙이 존재하는데, '**최대힙**'은 부모 노드가 자식노드보다 큰 힙을 말한다. 힙 정렬을 하기 위해서는 정해진 데이터를 힙 구조를 가지도록 만들어야한다. 

힙 정렬을 수행하기 위해서는 '**힙 생성 알고리즘**'을 사용한다. 힙 생성 알고리즘은 특정한 '하나의 노드'에 대해서 수행하는 것이다. 또 해당 '*하나의 노드를 제외하고는 최대 힙이 구성되어 있는 상태*' 라고 가정을 한다는 특징이 있다. 

'특정한 노드의 두 자식 중에서 더 큰 자식과 자신의 위치를 바꾸는 알고리즘'을 말하는데, 위치를 바꾼 뒤에도 여전히 자식이 존재한다면 자식이 더이상 존재하지 않을 때까지 자식중에서 더 큰 자식과 자신의 위치를 바꾸어야 한다. 

힙 생성 알고리즘은 전체 트리를 힙 구조를 가지도록 만든다는 점에서 중요하다. 

힙 생성 알고리즘의 시간 복잡도는 한번 자식 노드로 내려갈 때마다 노드의 갯수가 2배씩 증가한다는 점에서 O(logN)이다. 

완전 이진 트리를 배경으로 표현하고 배열을 다시 완전 이진 트리로 표현할 수 있어야한다. 모든 원소를 기준으로 힙 생성 알고리즘을 적용해 전체 트리를 힙 구조로 만든다. 데이터의 갯수가 N개 이므로 전체 트리를 힙 구조로 만드는 복잡도는 O(N * logN)이다. (모든 데이터를 기준으로 알고리즘을 쓰지 않아도 되기 때문에 O(N)에 가까운 속도 낼 수 있음)



=> **'힙 정렬'이란?**

**힙 생성 알고리즘을 사용해 특정 노드의 두 자식 중 더 큰 자식과 자신의 위치를 바꾸는** 방법이다.

소스코드로 확인해보면

```c++
#include<stdio.h>

int number = 9;
int heap[9] = {7, 6, 5, 8, 3, 5, 9, 1, 6};

int main(void){
	//먼저 전체 트리 구조를 최대 힙 구조로 바꿈 
	for(int i= 0 ; i < number; i++){
		int c = i;
		do {
			int root = (c - 1) / 2; //특정원소의 부모
			if(heap[root] < heap[c]){
				int temp = heap[root];
				heap[root] = heap[c];
				heap[c] = temp;
			} 
			c = root;
		} while (c != 0);
	}
	//크기를 줄여가며 반복적으로 힙을 구성
	//루트노드와 가장 마지막에 있는 원소와 바꿔줌 
	for(int i = number - 1; i >=0; i--){
		int temp = heap[0];
		heap[0] = heap[i];
		heap[i] = temp;
		int root = 0;
		int c = 1;
		 
		do{
			c = 2 * root + 1;
			//자식 중에 더 큰 값을 찾기 
			if(c < i - 1 && heap[c] < heap[c + 1]){
				c++;  //왼쪽과오른쪽중 더 큰값을 c에 넣도록 
			} 
			//루트보다 자식이 더 크다면 교환
			if(heap[root] < heap[c] && c < i) {
				int temp = heap[root];
				heap[root] = heap[c];
				heap[c] = temp;
			}
			root = c;
			}  while(c < i);
	}  
	//결과 출력
	for(int i = 0;i < number; i++){
		printf("%d ", heap[i]);
	} 
	
}
```



힙 정렬의 전체시간 복잡도는 => O(N * logN)

힙 생성 알고리즘의 시간 복잡도는 O(logN)이고 전체 데이터 갯수가 N개이므로 힙 정렬의 전체 시간 복잡도는 O(N * logN)가 된다. 

힙 정렬은 병합 정렬과 다르게 정렬을 위한 별도의 추가적인 배열이 필요하지 않기때문에 메모리 측면에서 효율적이라고 할 수 있다. 또 항상 O(N * logN)을 보장하기 때문에 이론적으로는 퀵 정렬이나 병합 정렬보다 더 우위에 있다. 하지만 단순히 속도만으로 비교하면 퀵 정렬이 평균적으로 더 빠르다.



최대 힙을 활용한 오름차순 정렬에서 힙 생성 함수(Heapify)는 특정 노드를 기준으로 위쪽으로 올라가는 상향식 구현방식과 아래쪽으로 내려가는 하향식 구현방식이 있다.(시간복잡도 동일)





*참고링크 : https://blog.naver.com/ndb796/221228342808*