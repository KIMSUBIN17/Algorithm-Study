## 알고리즘 공부 내용 정리

### 2. 탐색

#### 2. 깊이 우선 탐색(Depth First Search, DFS)

깊이 우선 탐색은 '**탐색을 할때 깊은 것 우선적으로 하여 탐색을 수행하는 탐색 알고리즘**'이다. 맹목적으로 각 노드를 탐색을 하고자 할때 사용가능한 탐색 기법이다. 너비 우선 탐색에서는 큐가 사용되었다면, 깊이 우선 탐색에는 **스택(Stack)**이 사용된다.  

=> **'깊이 우선 탐색'이란?**

'**탐색을 할때 깊이를 우선으로 하여 탐색을 수행하는 탐색 알고리즘**이다.

DFS는 맨 처음 시작 노드를 스에 삽입하면서 시작하고, 이와 동시에 시작 노드를 방문했다고 알려주는 '방문처리'를 해준다.

DFS는 아래 1,2번을 반복하며 수행된다.

1. 스택의 최상단 노드를 확인한다.

2. 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 노드를 스택에 넣고 방문처리 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 뺀다.

   ![image-20200827100743704](C:\Users\Subin\AppData\Roaming\Typora\typora-user-images\image-20200827100743704.png)
   
   

먼저 시작 노드 1을 스택에 삽입하면서 시작한다. 삽입과 동시에 시작 노드를 방문했으므로 방문처리를 한다. 스택에 있던 최상단 노드1을 확인해 인접한 노드 중에서 방문하지 않은 2번 노드를 스택에 넣는다. 그 후 2번 노드의 인접 노드 중 방문하지 않은 3번 노드를 스택에 넣는다. (현재 스택 3 2 1)

이어서 3번 노드의 인접 노드중에서 방문하지 않은 노드인 6번 노드를 스택에 넣는다. (현재 스택 6 3 2 1) 6번 노드의 인접 노드 중 방문하지 않는 7번 노드도 스택에 넣는다.(현재 스택  7 6 3 2 1) 그렇게되면 방문하지 않은 인접노드가 없기때문에 스택에서 최상단 노드를 빼게된다. 이 과정을 통해 7 6 3노드가 스택에서 빠져나온다. 이 후 다시 2번노드의 인접 노드중에서 방문하지 않은 4번 노드를 스택에 넣는다. (현재 스택 4 2 1) 4번 노드의 인접노드인 5를 스택에 넣는다.(현재 스택 5 4 2 1) 이렇게되면 이제 모든 노드가 방문처리되어 방문하지 않은 인접노드가 없기때문에 스택에서 노드가 하나씩 다 빠져나오게 된다. 따라서 방문 경로는 1 - 2 - 3 - 6 - 7 - 4 - 5 가 된다.

소스코드로 확인해보면

```c++
#include <iostream>
#include <vector>  

using namespace std;

int number = 7;
int c[8];  //방문처리를 위한 배열 
vector<int> a[8];  //총 7개의 노드가 각각 인접한 노드를 갖을 수 있도록

void dfs(int x){  //x값이 들어왔을때 현재 그 노드를 방문했다면 return 
	if(c[x]) return;
	c[x] = true;  //처음방문했다면 방문처리
	cout << x << ' ';   //해당 노드 출력 
	for(int i = 0; i < a[x].size() ;i++){  //해당노드와 인접한 노드를 방문
		int y = a[x][i];   
		dfs(y); 
	} 
} 

int main(void){
	//1과 2를 연결 
	a[1].push_back(2);  
	a[2].push_back(1); 
	//1과 3을 연결 
	a[1].push_back(3);  //하나의 간선마다 두개의 명령어 
	a[3].push_back(1);  
	//2와 3을 연결 
	a[2].push_back(3); 
	a[3].push_back(2); 
	//2와 4를 연결 
	a[2].push_back(4); 
	a[4].push_back(2);
	//2와 5를 연결 
	a[2].push_back(5);
	a[5].push_back(2);
	//3과 6을 연결 
	a[3].push_back(6);
	a[6].push_back(3);
	//3과 7을 연결 
	a[3].push_back(7);
	a[7].push_back(3);
	//4와 5를 연결 
	a[4].push_back(5);
	a[5].push_back(4);
	//6과 7을 연결 
	a[6].push_back(7);
	a[7].push_back(6);
	
	//시작점을 1로 DFS를 수행 
	dfs(1);   
	
	return 0; 
	
}
```

DFS 특징을 이용하여 다른 알고리즘에 적용하게 된다.



*참고링크 :https://blog.naver.com/ndb796/221230945092*