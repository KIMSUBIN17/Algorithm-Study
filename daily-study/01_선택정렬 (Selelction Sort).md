## c알고리즘 공부 내용 정리



알고리즘이란 ' 문제를 해결하는 절차'

> - 알고리즘은 입력,출력,유한성,명백성,효과성을 만족해야 한다.
>
> - 알고리즘은 분석을 통해 좋고 나쁨을 평가 할 수 있다.

-------------------------------------------------------

### 1. 정렬

#### 1. 선택 정렬( Selection Sort)
다음 숫자를 오름차순으로 정렬하려면 어떻게 해야할까?

1 10 5 8 7 6 4 3 2 9 

=> '선택 정렬'이란?

가장 작은 것을 선택해서 제일 앞으로 보내는 알고리즘

가장 원시적이고 기초적인 방법 중 하나



```c
#include<stdio.h>

int main(void){

	int i,j,min,index, temp;
	int array[10] = {1,10,5,8,7,6,4,3,2,9};
	for(i=0;i<10;i++){
		min = 9999;  //가장 큰 값을 넣는 이유? 
					//min은 항상 최소값을 선택해야하기때문에 처음에는 큰 값이 필요
		 
		for(j=i;j<10;j++) {
			if(min>array[j]){
				min = array[j];
							//탐색하고 있는 원소가 현재 최솟값보다 작으면
							//탐색하고 있는 현재 원소값으로 최솟값 변경 
				index = j;
			}
		}
		//swaping(가장 앞에 있는 값과 최솟값의 위치 교환) 
		 temp = array[i];
		 array[i] = array[index];
		 array[index] = temp;
	} 
	for(i = 0; i < 10; i++){
		printf("%d ", array[i]);
	}
	
	return 0;
}

```

	//i,j : 배열의 원소를 반복적으로 탐색하기위해 사용하는 변수
	//min : 최솟값을 일시적으로 담는 변수
	//temp :배열에서 두 숫자를 서로 바꾸기 위해 사용하는 변수
	//index :가장작은원소가 위치 
중요한 것은 데이터의 갯수가 N개일때 총 몇 번의 비교 연산을 진행해야 되는지이다.

위의 숫자를 통해 손으로 직접 정렬을 해보면 1~10까지 확인하기 위해 10번의 과정이 필요하기 때문에 

10 + 9 + 8 + 7 + ... + 1

=> 10 * (10 + 1) / 2 = 55번의 비교 연산 수행

=> N* (N + 1) / 2  (알고리즘의 실행시간에서는 나누기와 덧셈은 무시하고 차수만으로 체크)

=> O(N * N)   ->빅오표기법(특정 알고리즘의 수행시간을 가장 간략하게 표기)

선택 정렬은 대략 N* (N + 1) / 2번의 연산 수행하기 때문에 

선택 정렬의 시간 복잡도는 O(N^2)가 된다. 

N^2 은 단순하지만 정렬 알고리즘 중 가장 느리다고 여겨지는 비효율적 알고리즘이다.

그렇기 때문에 데이터의 값이 조금만 늘어나도 연산의 수가 크게 증가하기 때문에 처리 데이터가 많다면 피해야한다.