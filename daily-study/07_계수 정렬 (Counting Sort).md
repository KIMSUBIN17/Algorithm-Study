## 알고리즘 공부 내용 정리

### 1. 정렬

#### 7. 계수 정렬( Counting Sort)

계수 정렬은 ' 범위 조건'이 있는 경우에 '크기'를 기준으로 갯수만 세기 때문에 위치를 바꿀 필요가 없다. 모든 데이터에 한 번씩만 접근하면 되기때문에 그래서 지금까지 배운 정렬들중에서 가장 빠르다. 



=> **'계수 정렬'이란?**

**'범위 조건'이 있는 경우에 한해서 굉장히 빠른, '크기'를 기준으로 세는 알고리즘**이다.

1 3 2 4 3 2 5 3 1 2 3 4 4 3 5 1 2 3 5 2 3 1 4 3 5 1 2 1 1 1 

위와 같은 경우 정렬할 데이터의 갯수가 30개인데, 모든 데이터가 1~5사이에 속한다. 이렇게 범위 조건이 있는 경우에는 빠른 알고리즘으로 O(N)의 속도를 가진다. 

크기=1, 크기=2, 크기=3, 크기=4, 크기=5 인 count배열의 인덱스를 0으로 초기화한 상태로 시작하고, 앞에서 부터 해당하는 크기의 원소를 만나는 경우 데이터의 값을 1 더해준다. 이 같은 과정을 반복하면 

크기=1 -> 8, 크기=2 -> 6, 크기=3 -> 8, 크기=4 -> 4, 크기=5 -> 4 가 된다.

그리고 크기1~5까지 해당 숫자만큼 출력을 하면 1을 8번, 2를 6번, 3을 8번, 4를 4번, 5를 4번 출력하는식으로 정렬이 이루어 진다. 

각 위치에 해당하는 값을 1씩 증가시킴으로써 정렬이 된 것과 같은 효과를  나타낸다. 전체 데이터의 크기만큼 다 허용할 수 있는 크기의 배열을 만들어야하기때문에 데이터가 한정된 크기만 가능하기때문에 자주 사용할 수 있는 케이스의 알고리즘은 아니다.

소스코드로 확인해보면

```c
#include<stdio.h>

int main(void){
	int temp;
	int count[6];
	int array[30] = {1, 3, 2, 4, 3, 2, 5, 3, 1, 2,
					 3, 4, 4, 3, 5, 1, 2, 3, 5, 2,
					 3, 1, 4, 3, 5, 1, 2, 1, 1, 1};
					 
	for(int i = 0; i <=5; i++){
		count[i] = 0;  //각 배열을 0으로 초기화 
	} 
	//현재 만나는 데이터의 인덱스값을 1 더해줌 
	for(int i = 0; i < 30; i++){
		count[array[i]]++; 
	//배열의 인덱스는 0에서 시작하기때문
		
	}
	for(int i = 0; i <= 5; i++){
		if(count[i] !=0){   //데이터가  0이 아닌이상 데이터갯수만큼 출력 
			for(int j = 0; j < count[i]; j++) 
			printf("%d", i);
		}
	}
					 
					 
	return 0;
	
}
```



계수 정렬의 시간 복잡도는 => O(N)

모든 데이터의 크기 범위를 메모리 상에서 표현할 수 있는 경우에는 빠른 속도로 정렬을 수행할 수 있다





*참고링크 : https://blog.naver.com/ndb796/221228361368*