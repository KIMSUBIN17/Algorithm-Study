## 알고리즘 공부 내용 정리

### 4. 다이나믹 프로그래밍 (Dynamic Programming)

#### 1. 다이나믹 프로그래밍

다이나믹 프로그래밍은 '**하나의 문제는 단 한 번만 풀도록 하는 알고리즘**'이다. 한 번 푼것을 여러번 다시 푸는 비효율적인 알고리즘을 개선시키는 방법이다.

앞서 살펴본 상당수의 분할 정복 기법은 동일한 문제를 다시 반복해서 푼다는 단점이 있다.(분할 정복 기법은 '정렬'과 같은 몇몇 요소에 대해 동일한 문제를 다시 풀게되는 단점이 없음. 퀵이나 병합 정렬은 매우빠름) 피보치나 수열을 단순 분할 정복으로 풀게되면 비효율적임을 알 수있다. 피보나치 수열의 점화식은  D[i] = D[i -1] + dD[i - 2] 이다. 

위 공식을 따라 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...처럼 나아간다.

15번째 피보나치 수열을 구하려면 D[14]와 D[15]를 알아야하고, D[14]를 구하기 위해선 D[13]과 D[12]를 알아야 하듯이 동일한 식이 반복되고 있다. 이런 경우에 병합 정렬을 할 때 처럼 단순 분할 정복 기법을 사용하면, 이미 해결한 문제를 다시 반복적으로 해결하게 되기때문에 비효율적이다. 그래서 이 대신 동적 프로그래밍 기법을 사용한다.

다이나믹 프로그래밍은 아래 2가지 가정 하에 사용한다.

1번 가정. 큰 문제를 작은 문제로 나눌 수 있다.

2번 가정. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

즉, 크고 어려운 문제가 있으면 이것을 먼저 작게 나누어서 해결한 뒤 처리해 나중에 전체의 답을 구하는 것이다. 이 과정에서 '메모리제이션'이 사용된다는 점에서 분할정복과 다르다. '이미 계산한 결과는 배열에 저장함'으로써 나중에 동일한 계산을 해야할때는 저장된 값을 단순히 반환만 해주면 된다. 

재귀함수를 사용한 피보나치 수열을  소스코드로 확인해보면

```c
#include <stdio.h> 

int dp(int x){
	if(x == 1) return 1;
	if(x == 2) return 1;  
	//피보나치수열은 1,1로 시작(초기값명시) + 재귀함수 종료조건
	return dp(x - 1) + dp(x - 2);  //자신의 앞과 앞앞의 자리를 더한값 
	 
}
//재귀함수를 이용한 피보나치수열 
int main(void){
	printf("%d", dp(10));
} 


```

![image-20200827150418161](C:\Users\Subin\AppData\Roaming\Typora\typora-user-images\image-20200827150418161.png)

그런데 50번째 피보나치 수열을 구하려고 하면 실행이 되지않고 CPU가 계속 돌아간다. 피보나치 수열이 1개만 늘어나더라도 계산량은 2배로 늘어나기 때문에 50번째를 구하려면 2^50만큼의 많은 계산을 해야하는 것이다.

그래서 이를 해결하기 위해 메모리제이션 기법을 사용한다.

```c
#include <stdio.h> 

int d[100];  //결과 담을 수 있는 배열 

int dp(int x){
	if(x == 1) return 1;
	if(x == 2) return 1;  
	//
	if(d[x] != 0) return d[x];  //이미 구한 값이라면(동일한 값 불러오는경우) 구한 값 자체 반환 
	//특정한 순서의 피보나치 수열을 구한 적이 없다면 
	return d[x] = dp(x - 1) + dp(x - 2);  
	 
}

int main(void){
	printf("%d", dp(30));
} 
```



![image-20200827145138427](C:\Users\Subin\AppData\Roaming\Typora\typora-user-images\image-20200827145138427.png)

3번째수열의 합은 수열2와1 각각 1을 더한 2, 4번째 수열은 3번째와 2번째 수열의 합을 더한값을 넣어준다.

d[3] = 2, d[4] = 3

5번째수열은 4번째와 3번째 수열의 값을 더하는데,  3번째 수열의 값을 구할때 앞서 구하고 저장해둔 d[3] = 2를 바로 가져와 반환한다. 이미 계산된 결과는 배열 d에 저장되기 때문에 한번 구한 값을 다시 구할 필요가 없다. 그래서 메모이제이션 기법을 사용하면 시간복잡도가 O(N)으로 줄어든다. n을 구하려하면 이미 구했던 n-1과 n-2값을 더한값, 즉 일직선으로 내려가면서 찾기 때문에 일직선만큼만 연산하면 된다. (높이 n만큼만 계산하면됨)



#### >> 다이나믹 프로그래밍 타일링 문제 풀어보기 - 1

백준 11726번 2xn 타일링

```c++
#include <stdio.h> 

int d[1001];  //결과 담을 수 있는 배열 

int dp(int x){9
	if(x == 1) return 1;
	if(x == 2) return 2;  

	if(d[x] != 0) return d[x];  //이미 특정한 값구했다면 (동일한 값 불러오는경우) 구한 값 자체 반환 
	//특정한 순서의 피보나치 수열을 구한 적이 없다면 
	return d[x] = ( dp(x - 1) + dp(x - 2)) % 10007; //나머지값출력(값이 너무 커지지않게) 
	 
}

int main(void){
	int x;
	scanf("%d", &x);
	printf("%d",dp(x));
} 
```



#### >> 다이나믹 프로그래밍 타일링 문제 풀어보기 - 2

백준 11727번 2xn 타일링 2

```c
#include <stdio.h> 

int d[1001];  //결과 담을 수 있는 배열 

int dp(int x){
	if(x == 1) return 1;
	if(x == 2) return 3;  

	if(d[x] != 0) return d[x];  
	return d[x] = ( dp(x - 1) + 2 * dp(x - 2)) % 10007; 
	 
}

int main(void){
	int x;
	scanf("%d", &x);
	printf("%d",dp(x));
} 

```

점화식 : d[n] = d[n-1] + 2 * d[n-2]



*참고링크 https://blog.naver.com/ndb796/221233570962*