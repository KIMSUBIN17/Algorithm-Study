## 알고리즘 공부 내용 정리

### 1. 정렬

#### 5. 병합 정렬( Merge Sort)

퀵 정렬에 이어서 병합 정렬도 대표적인 '분할정복'방법을 채택한 알고리즘이다. 퀵 정렬과 동일하게 O(N * logN)의 시간 복잡도 가진다.

퀵 정렬은 피벗 값에 따라서 편향되게 분할될 가능성이 있어 최악의 경우O(N^2)의 시간 복잡도를 가지는데, 병합정렬은 항상 반으로 나누기 때문에 피벗값을이 없고 이 이유로  logN이 되도록 만들어 최악의 경우에도 O(N*logN)을 보장한다. 

병합 정렬은 하나의 큰 문제를 두개의 작은 문제로 분할한 뒤 각자 계산하고 나중에 합치는 방법을 사용한다. 즉, **일단 정확히 반으로 나누고 나중에 정렬**한다.

7 6 5 8 3 5 9 1의 숫자들을 오름차순으로 정렬한다고 생각해보자.

모두 크기가 1인 개별 배열 상태로 시작한다고 생각한다. 

1단계에서는 6 7 / 5 8 / 3 5 / 1 9 처럼 각 배열의 크기가 2개이다.

크기가 1개였던 것들을 두개 씩 묶어서 합친 것이다.

6 7 / 5 8을 예로 들어 설명하면, 왼쪽 집합에서는 i가 첫번째 원소를, 오른쪽 집합에서는 j가 첫번째 원소를 가리킨다. 정렬될 배열 k는 비어있는 상태이다. **'부분집합'은 이미 정렬이 되어있는 상태**라고 가정하기 때문에 정렬에 N만 걸린다. (삽입 정렬에서와 동일한 이유) 이미 정렬이 되어있는 두 개를 합치는 것은 시간 복잡도 O(N)이면 충분하기 때문이다. 

i와 j를 비교해서 더 작은 숫자를 k의 위치에 넣고 처리한 인덱스를 1씩 더해준다. 그 후 k,j가 한 칸 뒤로(오른쪽)으로 이동한다. 또 마찬가지로 i=6와 j=8을 비교해 6이 더 작으니까 6을 k의 위치에 삽입하고 i,k를 각각 1씩 더해준다. 이런식으로 반복하게 되면 정확히 N번만 처리하면 된다.

이런 과정을 통해 2단계에서는 크기가 2개였던것을 두 개씩 묶어서 5 6 7 8 / 1 3 5 9 처럼 크기가 4인 배열을 만든다.

마지막 3단계에서는 1 3 5 5 6 7 8 9가 된다.

이렇게 합치는 순간에 정렬을 수행해 합치는 단계는 오직 3단계면 된다.

합치는 갯수가 2배씩 증가한다는 점에서 2^3=8이므로 3단계만 필요하다는 것이다. 단계의 크기는 데이터의 갯수가 N개일때 logN을 유지하게 된다. 데이터 개수N만큼만 비교하면 되기 때문에 정렬 자체에 필요한 수행시간은 N이된다. 총 시간복잡도는 O(N * logN)이 된다.



=> **''병합 정렬'이란?**

**일단 정확히 반으로 나누고 나중에 정렬**하는 방법이다.

소스코드로 확인해보면

```c++
#include<stdio.h>

int number = 8;
int sorted[8];  //정렬된 결과담을 배열(정렬 배열은 반드시 전역변수로)

//m:시작 middle:중간  n:끝 
void merge(int a[], int m, int middle, int n ){  //새롭게 만들어지는 배열
	int i = m;
	int j = middle + 1;
	int k = m;  //i랑 동일한 위치 가짐
	
	//작은 순서대로 배열에 삽입
	while(i <= middle  && j <= n){
		if(a[i] <= a[j]){
			sorted[k] = a[i];
			i++;
		} else{
			sorted[k] = a[j];
			j++;
		}
		k++;
	} 
	//남은 데이터도 삽입
	if(i > middle) {   //i가 먼저 끝난 경우 -> 남은 j값 넣어주기 
		for(int t = j; t <=n; t++){
			sorted[k] = a[t];
			k++;
		}
		
	} else {
		for(int t = i; t <= middle; t++){
			sorted[k] = a[t];
			k++;
		}
	}
	//정렬된 배열을 삽입 
	for(int t = m ; t<= n; t++){
		a[t] = sorted[t];
	}
}

void mergeSort(int a[], int m, int n) {
	// 이외의 경우는 크기가 1개인 경우 
	if(m < n) {
		int middle = (m + n) / 2;
		mergeSort(a, m, middle);
		mergeSort(a, middle + 1, n);
		merge(a, m, middle, n);
	}
}

int main(void) {
	int array[number] = {7, 6, 5, 8, 3, 5, 9, 1};
	mergeSort(array, 0, number - 1);
	for(int i = 0; i < number; i++) {
		printf("%d ", array[i]);
	}
} 
```

병합 정렬 구현 시 반드시 정렬에 사용되는 배열은 **'전역변수'**로 선언해야한다. 함수 안에서 배열을 선언하게 되면 매 번 배열을 선언해야 하기때문에 메모리 자원 낭비가 클 수 있다. 그래서 병합 정렬은 **'기존의 데이터를 담을 추가적인 배열 공간이 필요하다'**는 점에서 메모리 활용이 비효율적이라는 문제가 있다.



병합 정렬의 평균 시간 복잡도는 => O(N * logN)

일반적인 경우에 퀵 정렬보다 느리지만 어떤 상황에서도 O(N * logN)을 보장할 수 있다는 점에서 효율적인 알고리즘이다.



*참조링크 https://blog.naver.com/ndb796/221227934987*